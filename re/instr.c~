
typedef struct _Instr {
  InstrFunc fn;
  void *data;
} Instr;

struct InstrConst {
  Obj val;
  Instr next;
};

static void
instrConstExec(struct VM *vm) {
  struct InstrConst *c = vm->pcData;
  vm->val = c->val;
  vm->pc = c->next.fn;
  vm->pcData = c->next.data;
}

struct InstrIf {
  Instr br1;
  Instr br2;
};

static void
instrIfExec(struct VM *vm) {
  struct InstrIf *i = vm->pcData;
  if (vm->val == True) {
    vm->pc = i->br1.fn;
    vm->pcData = i->br1.data;
  } else if (vm->val == False) {
    vm->pc = i->br2.fn;
    vm->pcData = i->br2.data;
  } else {
    // TODO?
  }
}

struct InstrNOP {
  Instr next;
};

static void
instrNOPExec(struct VM *vm) {
  struct InstrNOP *i = vm->pcData;
  vm->pc = i->next.fn;
  vm->pcData = i->next.data;
}

struct InstrPush {
  Instr next;
};

static void
instrPushExec(struct VM *vm) {
  struct InstrPush *i = vm->pcData;
  push(vm, vm->val);
  vm->pc = i->next.fn;
  vm->pcData = i->next.data;
}

struct InstrLocalRef {
  int idx;
  Instr next;
};

static void
instrLocalRefExec(struct VM *vm) {
  struct InstrLocalRef *i = vm->pcData;
  Obj v = vmGet(vm, i->idx);
  vm->val = v;
  vm->pc = i->next.fn;
  vm->pcData = i->next.data;
}

struct InstrClosureRef {
  int up;
  int idx;
  Instr next;
};

static void
instrClosureRefExec(struct VM *vm) {
  struct InstrClosureRef *instr = vm->pcData;
  Obj tmp = vmGet(vm, 1);
  for (int i=instr->up; i>0; i--) {
    tmp = closureParent(tmp);
  }
  vm->val = closureSlot[instr->idx];
  vm->pc = instr->next.fn;
  vm->pcData = instr->next.data;
}

struct InstrGlobalRef {
  Obj sym;
  Instr next;
};

static void
instrGlobalRefExec(struct VM *vm) {
  struct InstrGlobalRef *i = vm->pcData;
  Obj val = symbolGet(i->sym);
  if (val == NULL) {
    // TODO: panic("undefined symbol")
  }

  vm->val = val;
  vm->pc = i->next.fn;
  vm->pcData = i->next.Data;
}

struct primitive {
  int required;
  nativeFuncPtr builtin;
};

struct InstrPrimitive {
  int size;
  struct primitive prim;
  Instr next;
};

static void
instrPrimitiveExec(struct VM *vm) {
  struct InstrPrimitive *c = vm->pcData;
  if (c->size == prim->required) {
    c->prim.builtin(vm);
  } else if (c.size < prim->required) {
    // TODO:
    /* vm.val = makeCurry() */
  } else {
    // TODO: panic
  }

  if (c->next == NULL) {
    vmReturn(vm, vm->val);
  } else {
    vm->pc = c->next.fn;
    vm->pcData = c->next.data;
  }
}

struct InstrCall {
  int size;
  Instr next;
};

static void
instrCallExec(struct VM *vm) {
  struct InstrCall *c = vm->pcData;
  Obj fn = vmGet(vm, c->size);
  if (isclosure(fn)) {
    callClosure(c, vm, fn);
  } else if (iscurry(fn)) {
    // TODO:
  } else {
    // TODO: panic
  }
}

static void
callClosure(struct InstrCall *c, struct VM *vm, Obj clo) {
  int argc = c->size - 1;
  int required = closureRequired(clo);
  if (argc == required) {
    callClosureNormal(c, vm, clo);
  } else if (argc < required) {
    // TODO: curry
  } else {
  }
}

static void
callClosureNormal(struct InstrCall *c, struct VM *vm, Obj clo) {
  if (c->next.fn == NULL) {
    // TODO panic("should never here?")
  }

  if (c->next.fn == identity) { // Jump
    // Reuse the old stack
    for (int i=0; i<c->size; i++) {
      Obj arg = vmGet(-c->size + i);
      vmSet(i+1, arg);
    }
    vmResize(c->size + 1);
  } else { // Call
    int newStackBase = vm->stack.pos - c->size - 1;
    Obj cc = makeContinuation(vm->stack, c->next);
    vm->stack.base = newStackBase;
    vmSet(vm, 0, cc);
  }

  Instr code = closureCode(clo);
  vm->pc = code->fn;
  vm->pcData = code->data;
}
